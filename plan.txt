module.processing.data.aws_region.current: Reading...
module.governance.data.aws_region.current: Reading...
module.analytics.data.aws_region.current: Reading...
module.governance.data.aws_region.current: Read complete after 0s [id=us-east-1]
module.analytics.data.aws_region.current: Read complete after 0s [id=us-east-1]
module.processing.data.aws_region.current: Read complete after 0s [id=us-east-1]
module.governance.data.aws_caller_identity.current: Reading...
module.processing.data.aws_caller_identity.current: Reading...
module.analytics.data.aws_caller_identity.current: Reading...
module.governance.data.aws_caller_identity.current: Read complete after 0s [id=590184001530]
module.processing.data.aws_caller_identity.current: Read complete after 0s [id=590184001530]
module.analytics.data.aws_caller_identity.current: Read complete after 0s [id=590184001530]

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # module.analytics.aws_athena_workgroup.analytics will be created
  + resource "aws_athena_workgroup" "analytics" {
      + arn           = (known after apply)
      + force_destroy = false
      + id            = (known after apply)
      + name          = "datalake-workgroup-dev"
      + state         = "ENABLED"
      + tags_all      = (known after apply)

      + configuration {
          + enforce_workgroup_configuration    = true
          + publish_cloudwatch_metrics_enabled = true
          + requester_pays_enabled             = false

          + result_configuration {
              + output_location = "s3://datalake-athena-results-dev/output/"

              + encryption_configuration {
                  + encryption_option = "SSE_S3"
                }
            }
        }
    }

  # module.analytics.aws_cloudwatch_dashboard.analytics will be created
  + resource "aws_cloudwatch_dashboard" "analytics" {
      + dashboard_arn  = (known after apply)
      + dashboard_body = jsonencode(
            {
              + widgets = [
                  + {
                      + height     = 6
                      + properties = {
                          + metrics = [
                              + [
                                  + "AWS/Athena",
                                  + "ProcessedBytes",
                                  + "WorkGroup",
                                  + "datalake-workgroup-dev",
                                ],
                              + [
                                  + "AWS/Athena",
                                  + "QueryExecutionTime",
                                  + "WorkGroup",
                                  + "datalake-workgroup-dev",
                                ],
                            ]
                          + period  = 300
                          + region  = "us-east-1"
                          + stat    = "Average"
                          + title   = "Athena Query Metrics"
                        }
                      + type       = "metric"
                      + width      = 12
                      + x          = 0
                      + y          = 0
                    },
                ]
            }
        )
      + dashboard_name = "datalake-analytics-dev"
      + id             = (known after apply)
    }

  # module.analytics.aws_cloudwatch_metric_alarm.query_failed will be created
  + resource "aws_cloudwatch_metric_alarm" "query_failed" {
      + actions_enabled                       = true
      + alarm_description                     = "This metric monitors failed Athena queries"
      + alarm_name                            = "datalake-query-failed-dev"
      + arn                                   = (known after apply)
      + comparison_operator                   = "GreaterThanThreshold"
      + dimensions                            = {
          + "WorkGroup" = "datalake-workgroup-dev"
        }
      + evaluate_low_sample_count_percentiles = (known after apply)
      + evaluation_periods                    = 1
      + id                                    = (known after apply)
      + metric_name                           = "QueryFailed"
      + namespace                             = "AWS/Athena"
      + period                                = 300
      + statistic                             = "Sum"
      + tags_all                              = (known after apply)
      + threshold                             = 0
      + treat_missing_data                    = "missing"
    }

  # module.analytics.aws_iam_role.quicksight_role will be created
  + resource "aws_iam_role" "quicksight_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "quicksight.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "datalake-quicksight-role-dev"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # module.analytics.aws_iam_role_policy.quicksight_policy will be created
  + resource "aws_iam_role_policy" "quicksight_policy" {
      + id          = (known after apply)
      + name        = "datalake-quicksight-policy-dev"
      + name_prefix = (known after apply)
      + policy      = (known after apply)
      + role        = (known after apply)
    }

  # module.analytics.aws_s3_bucket.athena_results will be created
  + resource "aws_s3_bucket" "athena_results" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "datalake-athena-results-dev"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags_all                    = (known after apply)
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # module.analytics.aws_s3_bucket_public_access_block.athena_results will be created
  + resource "aws_s3_bucket_public_access_block" "athena_results" {
      + block_public_acls       = true
      + block_public_policy     = true
      + bucket                  = (known after apply)
      + id                      = (known after apply)
      + ignore_public_acls      = true
      + restrict_public_buckets = true
    }

  # module.governance.aws_cloudwatch_log_group.governance_audit will be created
  + resource "aws_cloudwatch_log_group" "governance_audit" {
      + arn               = (known after apply)
      + id                = (known after apply)
      + log_group_class   = (known after apply)
      + name              = "/aws/lakeformation/datalake-audit-dev"
      + name_prefix       = (known after apply)
      + retention_in_days = 90
      + skip_destroy      = false
      + tags_all          = (known after apply)
    }

  # module.governance.aws_config_config_rule.s3_encryption will be created
  + resource "aws_config_config_rule" "s3_encryption" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + name     = "datalake-s3-encryption-dev"
      + rule_id  = (known after apply)
      + tags_all = (known after apply)

      + evaluation_mode (known after apply)

      + scope {
          + compliance_resource_types = [
              + "AWS::S3::Bucket",
            ]
        }

      + source {
          + owner             = "AWS"
          + source_identifier = "S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED"
        }
    }

  # module.governance.aws_config_config_rule.s3_public_access will be created
  + resource "aws_config_config_rule" "s3_public_access" {
      + arn      = (known after apply)
      + id       = (known after apply)
      + name     = "datalake-s3-public-access-dev"
      + rule_id  = (known after apply)
      + tags_all = (known after apply)

      + evaluation_mode (known after apply)

      + scope {
          + compliance_resource_types = [
              + "AWS::S3::Bucket",
            ]
        }

      + source {
          + owner             = "AWS"
          + source_identifier = "S3_BUCKET_PUBLIC_READ_PROHIBITED"
        }
    }

  # module.governance.aws_glue_data_catalog_encryption_settings.example will be created
  + resource "aws_glue_data_catalog_encryption_settings" "example" {
      + catalog_id = (known after apply)
      + id         = (known after apply)

      + data_catalog_encryption_settings {
          + connection_password_encryption {
              + aws_kms_key_id                       = (known after apply)
              + return_connection_password_encrypted = true
            }
          + encryption_at_rest {
              + catalog_encryption_mode = "SSE-KMS"
              + sse_aws_kms_key_id      = (known after apply)
            }
        }
    }

  # module.governance.aws_iam_role.data_analyst_role will be created
  + resource "aws_iam_role" "data_analyst_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "quicksight.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "datalake-data-analyst-role-dev"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # module.governance.aws_iam_role.lakeformation_role will be created
  + resource "aws_iam_role" "lakeformation_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "lakeformation.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "datalake-lakeformation-role-dev"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # module.governance.aws_kms_alias.catalog_key will be created
  + resource "aws_kms_alias" "catalog_key" {
      + arn            = (known after apply)
      + id             = (known after apply)
      + name           = "alias/datalake-catalog-key-dev"
      + name_prefix    = (known after apply)
      + target_key_arn = (known after apply)
      + target_key_id  = (known after apply)
    }

  # module.governance.aws_kms_key.catalog_key will be created
  + resource "aws_kms_key" "catalog_key" {
      + arn                                = (known after apply)
      + bypass_policy_lockout_safety_check = false
      + customer_master_key_spec           = "SYMMETRIC_DEFAULT"
      + deletion_window_in_days            = 7
      + description                        = "KMS key for Data Catalog encryption"
      + enable_key_rotation                = true
      + id                                 = (known after apply)
      + is_enabled                         = true
      + key_id                             = (known after apply)
      + key_usage                          = "ENCRYPT_DECRYPT"
      + multi_region                       = (known after apply)
      + policy                             = (known after apply)
      + rotation_period_in_days            = (known after apply)
      + tags_all                           = (known after apply)
    }

  # module.governance.aws_lakeformation_data_lake_settings.settings will be created
  + resource "aws_lakeformation_data_lake_settings" "settings" {
      + admins                             = [
          + "arn:aws:iam::590184001530:user/cloud_user",
        ]
      + authorized_session_tag_value_list  = (known after apply)
      + external_data_filtering_allow_list = (known after apply)
      + id                                 = (known after apply)
      + parameters                         = (known after apply)
      + read_only_admins                   = (known after apply)
      + trusted_resource_owners            = (known after apply)

      + create_database_default_permissions (known after apply)

      + create_table_default_permissions (known after apply)
    }

  # module.governance.aws_lakeformation_permissions.data_analyst_permissions will be created
  + resource "aws_lakeformation_permissions" "data_analyst_permissions" {
      + catalog_resource              = false
      + id                            = (known after apply)
      + permissions                   = [
          + "SELECT",
        ]
      + permissions_with_grant_option = (known after apply)
      + principal                     = (known after apply)

      + data_location (known after apply)

      + database {
          + catalog_id = "590184001530"
          + name       = "datalake-dev"
        }

      + lf_tag (known after apply)

      + lf_tag_policy (known after apply)

      + table (known after apply)

      + table_with_columns (known after apply)
    }

  # module.governance.aws_lakeformation_resource.curated_bucket will be created
  + resource "aws_lakeformation_resource" "curated_bucket" {
      + arn                   = (known after apply)
      + hybrid_access_enabled = (known after apply)
      + id                    = (known after apply)
      + last_modified         = (known after apply)
      + role_arn              = (known after apply)
      + with_federation       = (known after apply)
    }

  # module.governance.aws_lakeformation_resource.processed_bucket will be created
  + resource "aws_lakeformation_resource" "processed_bucket" {
      + arn                   = (known after apply)
      + hybrid_access_enabled = (known after apply)
      + id                    = (known after apply)
      + last_modified         = (known after apply)
      + role_arn              = (known after apply)
      + with_federation       = (known after apply)
    }

  # module.governance.aws_lakeformation_resource.raw_bucket will be created
  + resource "aws_lakeformation_resource" "raw_bucket" {
      + arn                   = (known after apply)
      + hybrid_access_enabled = (known after apply)
      + id                    = (known after apply)
      + last_modified         = (known after apply)
      + role_arn              = (known after apply)
      + with_federation       = (known after apply)
    }

  # module.ingestion.aws_cloudwatch_log_group.firehose_logs will be created
  + resource "aws_cloudwatch_log_group" "firehose_logs" {
      + arn               = (known after apply)
      + id                = (known after apply)
      + log_group_class   = (known after apply)
      + name              = "/aws/firehose/datalake-ingestion-stream-dev"
      + name_prefix       = (known after apply)
      + retention_in_days = 30
      + skip_destroy      = false
      + tags_all          = (known after apply)
    }

  # module.ingestion.aws_cloudwatch_metric_alarm.firehose_delivery_failed will be created
  + resource "aws_cloudwatch_metric_alarm" "firehose_delivery_failed" {
      + actions_enabled                       = true
      + alarm_description                     = "This metric monitors failed deliveries to S3"
      + alarm_name                            = "datalake-firehose-delivery-failed-dev"
      + arn                                   = (known after apply)
      + comparison_operator                   = "GreaterThanThreshold"
      + dimensions                            = {
          + "DeliveryStreamName" = "datalake-ingestion-stream-dev"
        }
      + evaluate_low_sample_count_percentiles = (known after apply)
      + evaluation_periods                    = 2
      + id                                    = (known after apply)
      + metric_name                           = "DeliveryToS3.Failed"
      + namespace                             = "AWS/Firehose"
      + period                                = 300
      + statistic                             = "Sum"
      + tags_all                              = (known after apply)
      + threshold                             = 0
      + treat_missing_data                    = "missing"
    }

  # module.ingestion.aws_iam_role.firehose_role will be created
  + resource "aws_iam_role" "firehose_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "firehose.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "datalake-firehose-role-dev"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # module.ingestion.aws_iam_role_policy.firehose_policy will be created
  + resource "aws_iam_role_policy" "firehose_policy" {
      + id          = (known after apply)
      + name        = "datalake-firehose-policy-dev"
      + name_prefix = (known after apply)
      + policy      = (known after apply)
      + role        = (known after apply)
    }

  # module.ingestion.aws_kinesis_firehose_delivery_stream.data_ingestion will be created
  + resource "aws_kinesis_firehose_delivery_stream" "data_ingestion" {
      + arn            = (known after apply)
      + destination    = "extended_s3"
      + destination_id = (known after apply)
      + id             = (known after apply)
      + name           = "datalake-ingestion-stream-dev"
      + tags_all       = (known after apply)
      + version_id     = (known after apply)

      + extended_s3_configuration {
          + bucket_arn          = (known after apply)
          + buffering_interval  = 300
          + buffering_size      = 5
          + compression_format  = "GZIP"
          + custom_time_zone    = "UTC"
          + error_output_prefix = "errors/year=!{timestamp:yyyy}/month=!{timestamp:MM}/day=!{timestamp:dd}/!{firehose:error-output-type}/"
          + prefix              = "raw-data/year=!{timestamp:yyyy}/month=!{timestamp:MM}/day=!{timestamp:dd}/"
          + role_arn            = (known after apply)
          + s3_backup_mode      = "Disabled"

          + cloudwatch_logging_options (known after apply)
        }
    }

  # module.processing.aws_cloudwatch_event_rule.glue_job_schedule will be created
  + resource "aws_cloudwatch_event_rule" "glue_job_schedule" {
      + arn                 = (known after apply)
      + description         = "Schedule for running the Glue ETL job"
      + event_bus_name      = "default"
      + force_destroy       = false
      + id                  = (known after apply)
      + name                = "datalake-glue-job-schedule-dev"
      + name_prefix         = (known after apply)
      + schedule_expression = "cron(0 */12 * * ? *)"
      + tags_all            = (known after apply)
    }

  # module.processing.aws_cloudwatch_event_target.glue_job_target will be created
  + resource "aws_cloudwatch_event_target" "glue_job_target" {
      + arn            = "arn:aws:glue:us-east-1:590184001530:job/datalake-process-raw-dev"
      + event_bus_name = "default"
      + force_destroy  = false
      + id             = (known after apply)
      + role_arn       = (known after apply)
      + rule           = "datalake-glue-job-schedule-dev"
      + target_id      = "GlueJobTarget"
    }

  # module.processing.aws_cloudwatch_log_group.glue_logs will be created
  + resource "aws_cloudwatch_log_group" "glue_logs" {
      + arn               = (known after apply)
      + id                = (known after apply)
      + log_group_class   = (known after apply)
      + name              = "/aws-glue/datalake-dev"
      + name_prefix       = (known after apply)
      + retention_in_days = 30
      + skip_destroy      = false
      + tags_all          = (known after apply)
    }

  # module.processing.aws_cloudwatch_metric_alarm.glue_job_failure will be created
  + resource "aws_cloudwatch_metric_alarm" "glue_job_failure" {
      + actions_enabled                       = true
      + alarm_description                     = "This metric monitors Glue job failures"
      + alarm_name                            = "datalake-glue-job-failed-dev"
      + arn                                   = (known after apply)
      + comparison_operator                   = "GreaterThanThreshold"
      + dimensions                            = {
          + "JobName" = "datalake-process-raw-dev"
        }
      + evaluate_low_sample_count_percentiles = (known after apply)
      + evaluation_periods                    = 1
      + id                                    = (known after apply)
      + metric_name                           = "glue.driver.aggregate.numFailedTasks"
      + namespace                             = "AWS/Glue"
      + period                                = 300
      + statistic                             = "Sum"
      + tags_all                              = (known after apply)
      + threshold                             = 0
      + treat_missing_data                    = "missing"
    }

  # module.processing.aws_glue_catalog_database.data_catalog will be created
  + resource "aws_glue_catalog_database" "data_catalog" {
      + arn          = (known after apply)
      + catalog_id   = (known after apply)
      + id           = (known after apply)
      + location_uri = (known after apply)
      + name         = "datalake_catalog_dev"
      + tags_all     = (known after apply)

      + create_table_default_permission (known after apply)
    }

  # module.processing.aws_glue_crawler.raw_data will be created
  + resource "aws_glue_crawler" "raw_data" {
      + arn           = (known after apply)
      + database_name = "datalake_catalog_dev"
      + id            = (known after apply)
      + name          = "datalake-raw-crawler-dev"
      + role          = (known after apply)
      + schedule      = "cron(0 */6 * * ? *)"
      + tags_all      = (known after apply)

      + s3_target {
          + path = (known after apply)
        }
    }

  # module.processing.aws_glue_job.process_raw_data will be created
  + resource "aws_glue_job" "process_raw_data" {
      + arn               = (known after apply)
      + default_arguments = (known after apply)
      + glue_version      = "3.0"
      + id                = (known after apply)
      + max_capacity      = (known after apply)
      + name              = "datalake-process-raw-dev"
      + number_of_workers = 2
      + role_arn          = (known after apply)
      + tags_all          = (known after apply)
      + timeout           = (known after apply)
      + worker_type       = "G.1X"

      + command {
          + name            = "glueetl"
          + python_version  = "3"
          + runtime         = (known after apply)
          + script_location = (known after apply)
        }

      + execution_property {
          + max_concurrent_runs = 1
        }

      + notification_property (known after apply)
    }

  # module.processing.aws_iam_role.eventbridge_role will be created
  + resource "aws_iam_role" "eventbridge_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "events.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "datalake-eventbridge-role-dev"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # module.processing.aws_iam_role.glue_role will be created
  + resource "aws_iam_role" "glue_role" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "glue.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "datalake-glue-role-dev"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = (known after apply)
      + unique_id             = (known after apply)

      + inline_policy (known after apply)
    }

  # module.processing.aws_iam_role_policy.eventbridge_policy will be created
  + resource "aws_iam_role_policy" "eventbridge_policy" {
      + id          = (known after apply)
      + name        = "datalake-eventbridge-policy-dev"
      + name_prefix = (known after apply)
      + policy      = (known after apply)
      + role        = (known after apply)
    }

  # module.processing.aws_iam_role_policy.glue_policy will be created
  + resource "aws_iam_role_policy" "glue_policy" {
      + id          = (known after apply)
      + name        = "datalake-glue-policy-dev"
      + name_prefix = (known after apply)
      + policy      = (known after apply)
      + role        = (known after apply)
    }

  # module.processing.aws_s3_bucket.glue_scripts will be created
  + resource "aws_s3_bucket" "glue_scripts" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "datalake-glue-scripts-dev"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags_all                    = (known after apply)
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # module.processing.aws_s3_bucket_public_access_block.glue_scripts will be created
  + resource "aws_s3_bucket_public_access_block" "glue_scripts" {
      + block_public_acls       = true
      + block_public_policy     = true
      + bucket                  = (known after apply)
      + id                      = (known after apply)
      + ignore_public_acls      = true
      + restrict_public_buckets = true
    }

  # module.storage.aws_s3_bucket.curated will be created
  + resource "aws_s3_bucket" "curated" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "datalake-curated-dev"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags                        = {
          + "Zone" = "Curated"
        }
      + tags_all                    = {
          + "Zone" = "Curated"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # module.storage.aws_s3_bucket.processed will be created
  + resource "aws_s3_bucket" "processed" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "datalake-processed-dev"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags                        = {
          + "Zone" = "Processed"
        }
      + tags_all                    = {
          + "Zone" = "Processed"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # module.storage.aws_s3_bucket.raw will be created
  + resource "aws_s3_bucket" "raw" {
      + acceleration_status         = (known after apply)
      + acl                         = (known after apply)
      + arn                         = (known after apply)
      + bucket                      = "datalake-raw-dev"
      + bucket_domain_name          = (known after apply)
      + bucket_prefix               = (known after apply)
      + bucket_regional_domain_name = (known after apply)
      + force_destroy               = false
      + hosted_zone_id              = (known after apply)
      + id                          = (known after apply)
      + object_lock_enabled         = (known after apply)
      + policy                      = (known after apply)
      + region                      = (known after apply)
      + request_payer               = (known after apply)
      + tags                        = {
          + "Zone" = "Raw"
        }
      + tags_all                    = {
          + "Zone" = "Raw"
        }
      + website_domain              = (known after apply)
      + website_endpoint            = (known after apply)

      + cors_rule (known after apply)

      + grant (known after apply)

      + lifecycle_rule (known after apply)

      + logging (known after apply)

      + object_lock_configuration (known after apply)

      + replication_configuration (known after apply)

      + server_side_encryption_configuration (known after apply)

      + versioning (known after apply)

      + website (known after apply)
    }

  # module.storage.aws_s3_bucket_lifecycle_configuration.raw will be created
  + resource "aws_s3_bucket_lifecycle_configuration" "raw" {
      + bucket                                 = (known after apply)
      + id                                     = (known after apply)
      + transition_default_minimum_object_size = (known after apply)

      + rule {
          + id     = "transition_to_ia"
          + status = "Enabled"

          + transition {
              + days          = 90
              + storage_class = "STANDARD_IA"
                # (1 unchanged attribute hidden)
            }
        }
    }

  # module.storage.aws_s3_bucket_public_access_block.curated will be created
  + resource "aws_s3_bucket_public_access_block" "curated" {
      + block_public_acls       = true
      + block_public_policy     = true
      + bucket                  = (known after apply)
      + id                      = (known after apply)
      + ignore_public_acls      = true
      + restrict_public_buckets = true
    }

  # module.storage.aws_s3_bucket_public_access_block.processed will be created
  + resource "aws_s3_bucket_public_access_block" "processed" {
      + block_public_acls       = true
      + block_public_policy     = true
      + bucket                  = (known after apply)
      + id                      = (known after apply)
      + ignore_public_acls      = true
      + restrict_public_buckets = true
    }

  # module.storage.aws_s3_bucket_public_access_block.raw will be created
  + resource "aws_s3_bucket_public_access_block" "raw" {
      + block_public_acls       = true
      + block_public_policy     = true
      + bucket                  = (known after apply)
      + id                      = (known after apply)
      + ignore_public_acls      = true
      + restrict_public_buckets = true
    }

  # module.storage.aws_s3_bucket_server_side_encryption_configuration.curated will be created
  + resource "aws_s3_bucket_server_side_encryption_configuration" "curated" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + rule {
          + apply_server_side_encryption_by_default {
              + sse_algorithm     = "AES256"
                # (1 unchanged attribute hidden)
            }
        }
    }

  # module.storage.aws_s3_bucket_server_side_encryption_configuration.processed will be created
  + resource "aws_s3_bucket_server_side_encryption_configuration" "processed" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + rule {
          + apply_server_side_encryption_by_default {
              + sse_algorithm     = "AES256"
                # (1 unchanged attribute hidden)
            }
        }
    }

  # module.storage.aws_s3_bucket_server_side_encryption_configuration.raw will be created
  + resource "aws_s3_bucket_server_side_encryption_configuration" "raw" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + rule {
          + apply_server_side_encryption_by_default {
              + sse_algorithm     = "AES256"
                # (1 unchanged attribute hidden)
            }
        }
    }

  # module.storage.aws_s3_bucket_versioning.curated will be created
  + resource "aws_s3_bucket_versioning" "curated" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + versioning_configuration {
          + mfa_delete = (known after apply)
          + status     = "Enabled"
        }
    }

  # module.storage.aws_s3_bucket_versioning.processed will be created
  + resource "aws_s3_bucket_versioning" "processed" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + versioning_configuration {
          + mfa_delete = (known after apply)
          + status     = "Enabled"
        }
    }

  # module.storage.aws_s3_bucket_versioning.raw will be created
  + resource "aws_s3_bucket_versioning" "raw" {
      + bucket = (known after apply)
      + id     = (known after apply)

      + versioning_configuration {
          + mfa_delete = (known after apply)
          + status     = "Enabled"
        }
    }

Plan: 51 to add, 0 to change, 0 to destroy.

Changes to Outputs:
  + athena_workgroup           = "datalake-workgroup-dev"
  + curated_bucket_name        = (known after apply)
  + glue_catalog_database_name = "datalake-dev"
  + glue_job_name              = "datalake-process-raw-dev"
  + kinesis_firehose_name      = "datalake-ingestion-stream-dev"
  + processed_bucket_name      = (known after apply)
  + raw_bucket_name            = (known after apply)

─────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
