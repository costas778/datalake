[0m[1mmodule.governance.aws_iam_role.lakeformation_role: Refreshing state... [id=datalake-lakeformation-role-dev][0m
[0m[1mmodule.processing.aws_cloudwatch_event_rule.glue_job_schedule: Refreshing state... [id=datalake-glue-job-schedule-dev][0m
[0m[1mmodule.processing.aws_cloudwatch_log_group.glue_logs: Refreshing state... [id=/aws-glue/datalake-dev][0m
[0m[1mmodule.analytics.aws_iam_role.quicksight_role: Refreshing state... [id=datalake-quicksight-role-dev][0m
[0m[1mmodule.processing.aws_iam_role.glue_role: Refreshing state... [id=datalake-glue-role-dev][0m
[0m[1mmodule.processing.data.aws_caller_identity.current: Reading...[0m[0m
[0m[1mmodule.processing.aws_glue_catalog_database.data_catalog: Refreshing state... [id=590184001530:datalake_catalog_dev][0m
[0m[1mmodule.governance.data.aws_region.current: Reading...[0m[0m
[0m[1mmodule.governance.data.aws_region.current: Read complete after 0s [id=us-east-1][0m
[0m[1mmodule.processing.aws_iam_role.eventbridge_role: Refreshing state... [id=datalake-eventbridge-role-dev][0m
[0m[1mmodule.governance.aws_cloudwatch_log_group.governance_audit: Refreshing state... [id=/aws/lakeformation/datalake-audit-dev][0m
[0m[1mmodule.governance.aws_kms_key.catalog_key: Refreshing state... [id=0826887a-ecdc-45fc-8507-c8b8a07cb0c0][0m
[0m[1mmodule.processing.data.aws_caller_identity.current: Read complete after 0s [id=590184001530][0m
[0m[1mmodule.analytics.data.aws_caller_identity.current: Reading...[0m[0m
[0m[1mmodule.analytics.data.aws_caller_identity.current: Read complete after 0s [id=590184001530][0m
[0m[1mmodule.analytics.data.aws_region.current: Reading...[0m[0m
[0m[1mmodule.analytics.data.aws_region.current: Read complete after 0s [id=us-east-1][0m
[0m[1mmodule.governance.data.aws_caller_identity.current: Reading...[0m[0m
[0m[1mmodule.governance.data.aws_caller_identity.current: Read complete after 0s [id=590184001530][0m
[0m[1mmodule.governance.aws_iam_role.data_analyst_role: Refreshing state... [id=datalake-data-analyst-role-dev][0m
[0m[1mmodule.processing.data.aws_region.current: Reading...[0m[0m
[0m[1mmodule.processing.data.aws_region.current: Read complete after 0s [id=us-east-1][0m
[0m[1mmodule.storage.aws_s3_bucket.curated: Refreshing state... [id=datalake-curated-dev][0m
[0m[1mmodule.ingestion.aws_iam_role.firehose_role: Refreshing state... [id=datalake-firehose-role-dev][0m
[0m[1mmodule.governance.aws_kms_alias.catalog_key: Refreshing state... [id=alias/datalake-catalog-key-dev][0m
[0m[1mmodule.governance.aws_glue_data_catalog_encryption_settings.example: Refreshing state... [id=590184001530][0m
[0m[1mmodule.storage.aws_s3_bucket_server_side_encryption_configuration.curated: Refreshing state... [id=datalake-curated-dev][0m
[0m[1mmodule.storage.aws_s3_bucket_public_access_block.curated: Refreshing state... [id=datalake-curated-dev][0m
[0m[1mmodule.storage.aws_s3_bucket_versioning.curated: Refreshing state... [id=datalake-curated-dev][0m

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m
[31m-[0m/[32m+[0m destroy and then create replacement[0m

Terraform will perform the following actions:

[1m  # random_string.suffix[0m will be created
[0m  [32m+[0m[0m resource "random_string" "suffix" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m length      = 8
      [32m+[0m[0m lower       = true
      [32m+[0m[0m min_lower   = 0
      [32m+[0m[0m min_numeric = 0
      [32m+[0m[0m min_special = 0
      [32m+[0m[0m min_upper   = 0
      [32m+[0m[0m number      = true
      [32m+[0m[0m numeric     = true
      [32m+[0m[0m result      = (known after apply)
      [32m+[0m[0m special     = false
      [32m+[0m[0m upper       = false
    }

[1m  # module.analytics.aws_athena_workgroup.analytics[0m will be created
[0m  [32m+[0m[0m resource "aws_athena_workgroup" "analytics" {
      [32m+[0m[0m arn           = (known after apply)
      [32m+[0m[0m force_destroy = false
      [32m+[0m[0m id            = (known after apply)
      [32m+[0m[0m name          = "datalake-workgroup-dev"
      [32m+[0m[0m state         = "ENABLED"
      [32m+[0m[0m tags_all      = (known after apply)

      [32m+[0m[0m configuration {
          [32m+[0m[0m enforce_workgroup_configuration    = true
          [32m+[0m[0m publish_cloudwatch_metrics_enabled = true
          [32m+[0m[0m requester_pays_enabled             = false

          [32m+[0m[0m result_configuration {
              [32m+[0m[0m output_location = (known after apply)

              [32m+[0m[0m encryption_configuration {
                  [32m+[0m[0m encryption_option = "SSE_S3"
                }
            }
        }
    }

[1m  # module.analytics.aws_cloudwatch_dashboard.analytics[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_dashboard" "analytics" {
      [32m+[0m[0m dashboard_arn  = (known after apply)
      [32m+[0m[0m dashboard_body = jsonencode(
            {
              [32m+[0m[0m widgets = [
                  [32m+[0m[0m {
                      [32m+[0m[0m height     = 6
                      [32m+[0m[0m properties = {
                          [32m+[0m[0m metrics = [
                              [32m+[0m[0m [
                                  [32m+[0m[0m "AWS/Athena",
                                  [32m+[0m[0m "ProcessedBytes",
                                  [32m+[0m[0m "WorkGroup",
                                  [32m+[0m[0m "datalake-workgroup-dev",
                                ],
                              [32m+[0m[0m [
                                  [32m+[0m[0m "AWS/Athena",
                                  [32m+[0m[0m "QueryExecutionTime",
                                  [32m+[0m[0m "WorkGroup",
                                  [32m+[0m[0m "datalake-workgroup-dev",
                                ],
                            ]
                          [32m+[0m[0m period  = 300
                          [32m+[0m[0m region  = "us-east-1"
                          [32m+[0m[0m stat    = "Average"
                          [32m+[0m[0m title   = "Athena Query Metrics"
                        }
                      [32m+[0m[0m type       = "metric"
                      [32m+[0m[0m width      = 12
                      [32m+[0m[0m x          = 0
                      [32m+[0m[0m y          = 0
                    },
                ]
            }
        )
      [32m+[0m[0m dashboard_name = "datalake-analytics-dev"
      [32m+[0m[0m id             = (known after apply)
    }

[1m  # module.analytics.aws_cloudwatch_metric_alarm.query_failed[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_metric_alarm" "query_failed" {
      [32m+[0m[0m actions_enabled                       = true
      [32m+[0m[0m alarm_description                     = "This metric monitors failed Athena queries"
      [32m+[0m[0m alarm_name                            = "datalake-query-failed-dev"
      [32m+[0m[0m arn                                   = (known after apply)
      [32m+[0m[0m comparison_operator                   = "GreaterThanThreshold"
      [32m+[0m[0m dimensions                            = {
          [32m+[0m[0m "WorkGroup" = "datalake-workgroup-dev"
        }
      [32m+[0m[0m evaluate_low_sample_count_percentiles = (known after apply)
      [32m+[0m[0m evaluation_periods                    = 1
      [32m+[0m[0m id                                    = (known after apply)
      [32m+[0m[0m metric_name                           = "QueryFailed"
      [32m+[0m[0m namespace                             = "AWS/Athena"
      [32m+[0m[0m period                                = 300
      [32m+[0m[0m statistic                             = "Sum"
      [32m+[0m[0m tags_all                              = (known after apply)
      [32m+[0m[0m threshold                             = 0
      [32m+[0m[0m treat_missing_data                    = "missing"
    }

[1m  # module.analytics.aws_iam_role_policy.quicksight_policy[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy" "quicksight_policy" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m name        = "datalake-quicksight-policy-dev"
      [32m+[0m[0m name_prefix = (known after apply)
      [32m+[0m[0m policy      = (known after apply)
      [32m+[0m[0m role        = "datalake-quicksight-role-dev"
    }

[1m  # module.analytics.aws_s3_bucket.athena_results[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket" "athena_results" {
      [32m+[0m[0m acceleration_status         = (known after apply)
      [32m+[0m[0m acl                         = (known after apply)
      [32m+[0m[0m arn                         = (known after apply)
      [32m+[0m[0m bucket                      = (known after apply)
      [32m+[0m[0m bucket_domain_name          = (known after apply)
      [32m+[0m[0m bucket_prefix               = (known after apply)
      [32m+[0m[0m bucket_regional_domain_name = (known after apply)
      [32m+[0m[0m force_destroy               = false
      [32m+[0m[0m hosted_zone_id              = (known after apply)
      [32m+[0m[0m id                          = (known after apply)
      [32m+[0m[0m object_lock_enabled         = (known after apply)
      [32m+[0m[0m policy                      = (known after apply)
      [32m+[0m[0m region                      = (known after apply)
      [32m+[0m[0m request_payer               = (known after apply)
      [32m+[0m[0m tags_all                    = (known after apply)
      [32m+[0m[0m website_domain              = (known after apply)
      [32m+[0m[0m website_endpoint            = (known after apply)

      [32m+[0m[0m cors_rule (known after apply)

      [32m+[0m[0m grant (known after apply)

      [32m+[0m[0m lifecycle_rule (known after apply)

      [32m+[0m[0m logging (known after apply)

      [32m+[0m[0m object_lock_configuration (known after apply)

      [32m+[0m[0m replication_configuration (known after apply)

      [32m+[0m[0m server_side_encryption_configuration (known after apply)

      [32m+[0m[0m versioning (known after apply)

      [32m+[0m[0m website (known after apply)
    }

[1m  # module.analytics.aws_s3_bucket_public_access_block.athena_results[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_public_access_block" "athena_results" {
      [32m+[0m[0m block_public_acls       = true
      [32m+[0m[0m block_public_policy     = true
      [32m+[0m[0m bucket                  = (known after apply)
      [32m+[0m[0m id                      = (known after apply)
      [32m+[0m[0m ignore_public_acls      = true
      [32m+[0m[0m restrict_public_buckets = true
    }

[1m  # module.governance.aws_cloudwatch_log_group.governance_audit[0m must be [1m[31mreplaced[0m
[0m[31m-[0m/[32m+[0m[0m resource "aws_cloudwatch_log_group" "governance_audit" {
      [33m~[0m[0m arn               = "arn:aws:logs:us-east-1:590184001530:log-group:/aws/lakeformation/datalake-audit-dev" -> (known after apply)
      [33m~[0m[0m id                = "/aws/lakeformation/datalake-audit-dev" -> (known after apply)
      [33m~[0m[0m log_group_class   = "STANDARD" -> (known after apply)
      [33m~[0m[0m name              = "/aws/lakeformation/datalake-audit-dev" -> (known after apply) [31m# forces replacement[0m[0m
      [32m+[0m[0m name_prefix       = (known after apply)
      [31m-[0m[0m tags              = {} [90m-> null[0m[0m
      [33m~[0m[0m tags_all          = {} -> (known after apply)
        [90m# (3 unchanged attributes hidden)[0m[0m
    }

[1m  # module.governance.aws_config_config_rule.s3_encryption[0m will be created
[0m  [32m+[0m[0m resource "aws_config_config_rule" "s3_encryption" {
      [32m+[0m[0m arn      = (known after apply)
      [32m+[0m[0m id       = (known after apply)
      [32m+[0m[0m name     = (known after apply)
      [32m+[0m[0m rule_id  = (known after apply)
      [32m+[0m[0m tags_all = (known after apply)

      [32m+[0m[0m evaluation_mode (known after apply)

      [32m+[0m[0m scope {
          [32m+[0m[0m compliance_resource_types = [
              [32m+[0m[0m "AWS::S3::Bucket",
            ]
        }

      [32m+[0m[0m source {
          [32m+[0m[0m owner             = "AWS"
          [32m+[0m[0m source_identifier = "S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED"
        }
    }

[1m  # module.governance.aws_config_config_rule.s3_public_access[0m will be created
[0m  [32m+[0m[0m resource "aws_config_config_rule" "s3_public_access" {
      [32m+[0m[0m arn      = (known after apply)
      [32m+[0m[0m id       = (known after apply)
      [32m+[0m[0m name     = (known after apply)
      [32m+[0m[0m rule_id  = (known after apply)
      [32m+[0m[0m tags_all = (known after apply)

      [32m+[0m[0m evaluation_mode (known after apply)

      [32m+[0m[0m scope {
          [32m+[0m[0m compliance_resource_types = [
              [32m+[0m[0m "AWS::S3::Bucket",
            ]
        }

      [32m+[0m[0m source {
          [32m+[0m[0m owner             = "AWS"
          [32m+[0m[0m source_identifier = "S3_BUCKET_PUBLIC_READ_PROHIBITED"
        }
    }

[1m  # module.governance.aws_config_configuration_recorder.recorder[0m will be created
[0m  [32m+[0m[0m resource "aws_config_configuration_recorder" "recorder" {
      [32m+[0m[0m id       = (known after apply)
      [32m+[0m[0m name     = (known after apply)
      [32m+[0m[0m role_arn = (known after apply)

      [32m+[0m[0m recording_group {
          [32m+[0m[0m all_supported = true

          [32m+[0m[0m exclusion_by_resource_types (known after apply)

          [32m+[0m[0m recording_strategy {
              [32m+[0m[0m use_only = "ALL_SUPPORTED_RESOURCE_TYPES"
            }
        }

      [32m+[0m[0m recording_mode (known after apply)
    }

[1m  # module.governance.aws_config_configuration_recorder_status.recorder_status[0m will be created
[0m  [32m+[0m[0m resource "aws_config_configuration_recorder_status" "recorder_status" {
      [32m+[0m[0m id         = (known after apply)
      [32m+[0m[0m is_enabled = true
      [32m+[0m[0m name       = (known after apply)
    }

[1m  # module.governance.aws_iam_role.config_role[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role" "config_role" {
      [32m+[0m[0m arn                   = (known after apply)
      [32m+[0m[0m assume_role_policy    = jsonencode(
            {
              [32m+[0m[0m Statement = [
                  [32m+[0m[0m {
                      [32m+[0m[0m Action    = "sts:AssumeRole"
                      [32m+[0m[0m Effect    = "Allow"
                      [32m+[0m[0m Principal = {
                          [32m+[0m[0m Service = "config.amazonaws.com"
                        }
                    },
                ]
              [32m+[0m[0m Version   = "2012-10-17"
            }
        )
      [32m+[0m[0m create_date           = (known after apply)
      [32m+[0m[0m force_detach_policies = false
      [32m+[0m[0m id                    = (known after apply)
      [32m+[0m[0m managed_policy_arns   = (known after apply)
      [32m+[0m[0m max_session_duration  = 3600
      [32m+[0m[0m name                  = (known after apply)
      [32m+[0m[0m name_prefix           = (known after apply)
      [32m+[0m[0m path                  = "/"
      [32m+[0m[0m tags_all              = (known after apply)
      [32m+[0m[0m unique_id             = (known after apply)

      [32m+[0m[0m inline_policy (known after apply)
    }

[1m  # module.governance.aws_iam_role.data_analyst_role[0m must be [1m[31mreplaced[0m
[0m[31m-[0m/[32m+[0m[0m resource "aws_iam_role" "data_analyst_role" {
      [33m~[0m[0m arn                   = "arn:aws:iam::590184001530:role/datalake-data-analyst-role-dev" -> (known after apply)
      [33m~[0m[0m create_date           = "2024-11-21T15:54:31Z" -> (known after apply)
      [33m~[0m[0m id                    = "datalake-data-analyst-role-dev" -> (known after apply)
      [33m~[0m[0m managed_policy_arns   = [] -> (known after apply)
      [33m~[0m[0m name                  = "datalake-data-analyst-role-dev" -> (known after apply) [31m# forces replacement[0m[0m
      [32m+[0m[0m name_prefix           = (known after apply)
      [31m-[0m[0m tags                  = {} [90m-> null[0m[0m
      [33m~[0m[0m tags_all              = {} -> (known after apply)
      [33m~[0m[0m unique_id             = "AROAYS2NVF75CRC7BFQRW" -> (known after apply)
        [90m# (6 unchanged attributes hidden)[0m[0m

      [33m~[0m[0m inline_policy (known after apply)
    }

[1m  # module.governance.aws_iam_role_policy.config_policy[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy" "config_policy" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m name        = "datalake-config-policy-dev"
      [32m+[0m[0m name_prefix = (known after apply)
      [32m+[0m[0m policy      = jsonencode(
            {
              [32m+[0m[0m Statement = [
                  [32m+[0m[0m {
                      [32m+[0m[0m Action   = [
                          [32m+[0m[0m "s3:*",
                          [32m+[0m[0m "config:Put*",
                          [32m+[0m[0m "config:Get*",
                          [32m+[0m[0m "config:List*",
                          [32m+[0m[0m "config:Describe*",
                        ]
                      [32m+[0m[0m Effect   = "Allow"
                      [32m+[0m[0m Resource = "*"
                    },
                ]
              [32m+[0m[0m Version   = "2012-10-17"
            }
        )
      [32m+[0m[0m role        = (known after apply)
    }

[1m  # module.governance.aws_iam_role_policy.lakeformation_admin[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy" "lakeformation_admin" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m name        = (known after apply)
      [32m+[0m[0m name_prefix = (known after apply)
      [32m+[0m[0m policy      = jsonencode(
            {
              [32m+[0m[0m Statement = [
                  [32m+[0m[0m {
                      [32m+[0m[0m Action   = [
                          [32m+[0m[0m "lakeformation:PutDataLakeSettings",
                          [32m+[0m[0m "lakeformation:RegisterResource",
                          [32m+[0m[0m "lakeformation:GrantPermissions",
                          [32m+[0m[0m "lakeformation:GetDataLakeSettings",
                          [32m+[0m[0m "lakeformation:GetResource",
                        ]
                      [32m+[0m[0m Effect   = "Allow"
                      [32m+[0m[0m Resource = "*"
                    },
                ]
              [32m+[0m[0m Version   = "2012-10-17"
            }
        )
      [32m+[0m[0m role        = "datalake-lakeformation-role-dev"
    }

[1m  # module.governance.aws_kms_alias.catalog_key[0m must be [1m[31mreplaced[0m
[0m[31m-[0m/[32m+[0m[0m resource "aws_kms_alias" "catalog_key" {
      [33m~[0m[0m arn            = "arn:aws:kms:us-east-1:590184001530:alias/datalake-catalog-key-dev" -> (known after apply)
      [33m~[0m[0m id             = "alias/datalake-catalog-key-dev" -> (known after apply)
      [33m~[0m[0m name           = "alias/datalake-catalog-key-dev" -> (known after apply) [31m# forces replacement[0m[0m
      [32m+[0m[0m name_prefix    = (known after apply)
      [33m~[0m[0m target_key_arn = "arn:aws:kms:us-east-1:590184001530:key/0826887a-ecdc-45fc-8507-c8b8a07cb0c0" -> (known after apply)
        [90m# (1 unchanged attribute hidden)[0m[0m
    }

[1m  # module.governance.aws_lakeformation_data_lake_settings.settings[0m will be created
[0m  [32m+[0m[0m resource "aws_lakeformation_data_lake_settings" "settings" {
      [32m+[0m[0m admins                             = [
          [32m+[0m[0m "arn:aws:iam::590184001530:user/cloud_user",
        ]
      [32m+[0m[0m authorized_session_tag_value_list  = (known after apply)
      [32m+[0m[0m external_data_filtering_allow_list = (known after apply)
      [32m+[0m[0m id                                 = (known after apply)
      [32m+[0m[0m parameters                         = (known after apply)
      [32m+[0m[0m read_only_admins                   = (known after apply)
      [32m+[0m[0m trusted_resource_owners            = (known after apply)

      [32m+[0m[0m create_database_default_permissions (known after apply)

      [32m+[0m[0m create_table_default_permissions (known after apply)
    }

[1m  # module.governance.aws_lakeformation_permissions.data_analyst_permissions[0m will be created
[0m  [32m+[0m[0m resource "aws_lakeformation_permissions" "data_analyst_permissions" {
      [32m+[0m[0m catalog_resource              = false
      [32m+[0m[0m id                            = (known after apply)
      [32m+[0m[0m permissions                   = [
          [32m+[0m[0m "SELECT",
        ]
      [32m+[0m[0m permissions_with_grant_option = (known after apply)
      [32m+[0m[0m principal                     = (known after apply)

      [32m+[0m[0m data_location (known after apply)

      [32m+[0m[0m database {
          [32m+[0m[0m catalog_id = "590184001530"
          [32m+[0m[0m name       = "datalake-dev"
        }

      [32m+[0m[0m lf_tag (known after apply)

      [32m+[0m[0m lf_tag_policy (known after apply)

      [32m+[0m[0m table (known after apply)

      [32m+[0m[0m table_with_columns (known after apply)
    }

[1m  # module.governance.aws_lakeformation_resource.curated_bucket[0m will be created
[0m  [32m+[0m[0m resource "aws_lakeformation_resource" "curated_bucket" {
      [32m+[0m[0m arn                   = "arn:aws:s3:::datalake-curated-dev"
      [32m+[0m[0m hybrid_access_enabled = (known after apply)
      [32m+[0m[0m id                    = (known after apply)
      [32m+[0m[0m last_modified         = (known after apply)
      [32m+[0m[0m role_arn              = (known after apply)
      [32m+[0m[0m with_federation       = (known after apply)
    }

[1m  # module.governance.aws_lakeformation_resource.processed_bucket[0m will be created
[0m  [32m+[0m[0m resource "aws_lakeformation_resource" "processed_bucket" {
      [32m+[0m[0m arn                   = (known after apply)
      [32m+[0m[0m hybrid_access_enabled = (known after apply)
      [32m+[0m[0m id                    = (known after apply)
      [32m+[0m[0m last_modified         = (known after apply)
      [32m+[0m[0m role_arn              = (known after apply)
      [32m+[0m[0m with_federation       = (known after apply)
    }

[1m  # module.governance.aws_lakeformation_resource.raw_bucket[0m will be created
[0m  [32m+[0m[0m resource "aws_lakeformation_resource" "raw_bucket" {
      [32m+[0m[0m arn                   = (known after apply)
      [32m+[0m[0m hybrid_access_enabled = (known after apply)
      [32m+[0m[0m id                    = (known after apply)
      [32m+[0m[0m last_modified         = (known after apply)
      [32m+[0m[0m role_arn              = (known after apply)
      [32m+[0m[0m with_federation       = (known after apply)
    }

[1m  # module.ingestion.aws_cloudwatch_log_group.firehose_logs[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_log_group" "firehose_logs" {
      [32m+[0m[0m arn               = (known after apply)
      [32m+[0m[0m id                = (known after apply)
      [32m+[0m[0m log_group_class   = (known after apply)
      [32m+[0m[0m name              = "/aws/firehose/datalake-ingestion-stream-dev"
      [32m+[0m[0m name_prefix       = (known after apply)
      [32m+[0m[0m retention_in_days = 30
      [32m+[0m[0m skip_destroy      = false
      [32m+[0m[0m tags_all          = (known after apply)
    }

[1m  # module.ingestion.aws_cloudwatch_metric_alarm.firehose_delivery_failed[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_metric_alarm" "firehose_delivery_failed" {
      [32m+[0m[0m actions_enabled                       = true
      [32m+[0m[0m alarm_description                     = "This metric monitors failed deliveries to S3"
      [32m+[0m[0m alarm_name                            = "datalake-firehose-delivery-failed-dev"
      [32m+[0m[0m arn                                   = (known after apply)
      [32m+[0m[0m comparison_operator                   = "GreaterThanThreshold"
      [32m+[0m[0m dimensions                            = {
          [32m+[0m[0m "DeliveryStreamName" = "datalake-ingestion-stream-dev"
        }
      [32m+[0m[0m evaluate_low_sample_count_percentiles = (known after apply)
      [32m+[0m[0m evaluation_periods                    = 2
      [32m+[0m[0m id                                    = (known after apply)
      [32m+[0m[0m metric_name                           = "DeliveryToS3.Failed"
      [32m+[0m[0m namespace                             = "AWS/Firehose"
      [32m+[0m[0m period                                = 300
      [32m+[0m[0m statistic                             = "Sum"
      [32m+[0m[0m tags_all                              = (known after apply)
      [32m+[0m[0m threshold                             = 0
      [32m+[0m[0m treat_missing_data                    = "missing"
    }

[1m  # module.ingestion.aws_iam_role_policy.firehose_policy[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy" "firehose_policy" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m name        = "datalake-firehose-policy-dev"
      [32m+[0m[0m name_prefix = (known after apply)
      [32m+[0m[0m policy      = (known after apply)
      [32m+[0m[0m role        = "datalake-firehose-role-dev"
    }

[1m  # module.ingestion.aws_kinesis_firehose_delivery_stream.data_ingestion[0m will be created
[0m  [32m+[0m[0m resource "aws_kinesis_firehose_delivery_stream" "data_ingestion" {
      [32m+[0m[0m arn            = (known after apply)
      [32m+[0m[0m destination    = "extended_s3"
      [32m+[0m[0m destination_id = (known after apply)
      [32m+[0m[0m id             = (known after apply)
      [32m+[0m[0m name           = "datalake-ingestion-stream-dev"
      [32m+[0m[0m tags_all       = (known after apply)
      [32m+[0m[0m version_id     = (known after apply)

      [32m+[0m[0m extended_s3_configuration {
          [32m+[0m[0m bucket_arn          = (known after apply)
          [32m+[0m[0m buffering_interval  = 300
          [32m+[0m[0m buffering_size      = 5
          [32m+[0m[0m compression_format  = "GZIP"
          [32m+[0m[0m custom_time_zone    = "UTC"
          [32m+[0m[0m error_output_prefix = "errors/year=!{timestamp:yyyy}/month=!{timestamp:MM}/day=!{timestamp:dd}/!{firehose:error-output-type}/"
          [32m+[0m[0m prefix              = "raw-data/year=!{timestamp:yyyy}/month=!{timestamp:MM}/day=!{timestamp:dd}/"
          [32m+[0m[0m role_arn            = "arn:aws:iam::590184001530:role/datalake-firehose-role-dev"
          [32m+[0m[0m s3_backup_mode      = "Disabled"

          [32m+[0m[0m cloudwatch_logging_options (known after apply)
        }
    }

[1m  # module.processing.aws_cloudwatch_event_target.glue_job_target[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_event_target" "glue_job_target" {
      [32m+[0m[0m arn            = "arn:aws:glue:us-east-1:590184001530:job/datalake-process-raw-dev"
      [32m+[0m[0m event_bus_name = "default"
      [32m+[0m[0m force_destroy  = false
      [32m+[0m[0m id             = (known after apply)
      [32m+[0m[0m role_arn       = "arn:aws:iam::590184001530:role/datalake-eventbridge-role-dev"
      [32m+[0m[0m rule           = "datalake-glue-job-schedule-dev"
      [32m+[0m[0m target_id      = "GlueJobTarget"
    }

[1m  # module.processing.aws_cloudwatch_metric_alarm.glue_job_failure[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_metric_alarm" "glue_job_failure" {
      [32m+[0m[0m actions_enabled                       = true
      [32m+[0m[0m alarm_description                     = "This metric monitors Glue job failures"
      [32m+[0m[0m alarm_name                            = "datalake-glue-job-failed-dev"
      [32m+[0m[0m arn                                   = (known after apply)
      [32m+[0m[0m comparison_operator                   = "GreaterThanThreshold"
      [32m+[0m[0m dimensions                            = {
          [32m+[0m[0m "JobName" = "datalake-process-raw-dev"
        }
      [32m+[0m[0m evaluate_low_sample_count_percentiles = (known after apply)
      [32m+[0m[0m evaluation_periods                    = 1
      [32m+[0m[0m id                                    = (known after apply)
      [32m+[0m[0m metric_name                           = "glue.driver.aggregate.numFailedTasks"
      [32m+[0m[0m namespace                             = "AWS/Glue"
      [32m+[0m[0m period                                = 300
      [32m+[0m[0m statistic                             = "Sum"
      [32m+[0m[0m tags_all                              = (known after apply)
      [32m+[0m[0m threshold                             = 0
      [32m+[0m[0m treat_missing_data                    = "missing"
    }

[1m  # module.processing.aws_glue_crawler.raw_data[0m will be created
[0m  [32m+[0m[0m resource "aws_glue_crawler" "raw_data" {
      [32m+[0m[0m arn           = (known after apply)
      [32m+[0m[0m database_name = "datalake_catalog_dev"
      [32m+[0m[0m id            = (known after apply)
      [32m+[0m[0m name          = "datalake-raw-crawler-dev"
      [32m+[0m[0m role          = "arn:aws:iam::590184001530:role/datalake-glue-role-dev"
      [32m+[0m[0m schedule      = "cron(0 */6 * * ? *)"
      [32m+[0m[0m tags_all      = (known after apply)

      [32m+[0m[0m s3_target {
          [32m+[0m[0m path = (known after apply)
        }
    }

[1m  # module.processing.aws_glue_job.process_raw_data[0m will be created
[0m  [32m+[0m[0m resource "aws_glue_job" "process_raw_data" {
      [32m+[0m[0m arn               = (known after apply)
      [32m+[0m[0m default_arguments = (known after apply)
      [32m+[0m[0m glue_version      = "3.0"
      [32m+[0m[0m id                = (known after apply)
      [32m+[0m[0m max_capacity      = (known after apply)
      [32m+[0m[0m name              = "datalake-process-raw-dev"
      [32m+[0m[0m number_of_workers = 2
      [32m+[0m[0m role_arn          = "arn:aws:iam::590184001530:role/datalake-glue-role-dev"
      [32m+[0m[0m tags_all          = (known after apply)
      [32m+[0m[0m timeout           = (known after apply)
      [32m+[0m[0m worker_type       = "G.1X"

      [32m+[0m[0m command {
          [32m+[0m[0m name            = "glueetl"
          [32m+[0m[0m python_version  = "3"
          [32m+[0m[0m runtime         = (known after apply)
          [32m+[0m[0m script_location = (known after apply)
        }

      [32m+[0m[0m execution_property {
          [32m+[0m[0m max_concurrent_runs = 1
        }

      [32m+[0m[0m notification_property (known after apply)
    }

[1m  # module.processing.aws_iam_role_policy.eventbridge_policy[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy" "eventbridge_policy" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m name        = "datalake-eventbridge-policy-dev"
      [32m+[0m[0m name_prefix = (known after apply)
      [32m+[0m[0m policy      = (known after apply)
      [32m+[0m[0m role        = "datalake-eventbridge-role-dev"
    }

[1m  # module.processing.aws_iam_role_policy.glue_policy[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy" "glue_policy" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m name        = "datalake-glue-policy-dev"
      [32m+[0m[0m name_prefix = (known after apply)
      [32m+[0m[0m policy      = (known after apply)
      [32m+[0m[0m role        = "datalake-glue-role-dev"
    }

[1m  # module.processing.aws_s3_bucket.glue_scripts[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket" "glue_scripts" {
      [32m+[0m[0m acceleration_status         = (known after apply)
      [32m+[0m[0m acl                         = (known after apply)
      [32m+[0m[0m arn                         = (known after apply)
      [32m+[0m[0m bucket                      = "datalake-glue-scripts-dev"
      [32m+[0m[0m bucket_domain_name          = (known after apply)
      [32m+[0m[0m bucket_prefix               = (known after apply)
      [32m+[0m[0m bucket_regional_domain_name = (known after apply)
      [32m+[0m[0m force_destroy               = false
      [32m+[0m[0m hosted_zone_id              = (known after apply)
      [32m+[0m[0m id                          = (known after apply)
      [32m+[0m[0m object_lock_enabled         = (known after apply)
      [32m+[0m[0m policy                      = (known after apply)
      [32m+[0m[0m region                      = (known after apply)
      [32m+[0m[0m request_payer               = (known after apply)
      [32m+[0m[0m tags_all                    = (known after apply)
      [32m+[0m[0m website_domain              = (known after apply)
      [32m+[0m[0m website_endpoint            = (known after apply)

      [32m+[0m[0m cors_rule (known after apply)

      [32m+[0m[0m grant (known after apply)

      [32m+[0m[0m lifecycle_rule (known after apply)

      [32m+[0m[0m logging (known after apply)

      [32m+[0m[0m object_lock_configuration (known after apply)

      [32m+[0m[0m replication_configuration (known after apply)

      [32m+[0m[0m server_side_encryption_configuration (known after apply)

      [32m+[0m[0m versioning (known after apply)

      [32m+[0m[0m website (known after apply)
    }

[1m  # module.processing.aws_s3_bucket_public_access_block.glue_scripts[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_public_access_block" "glue_scripts" {
      [32m+[0m[0m block_public_acls       = true
      [32m+[0m[0m block_public_policy     = true
      [32m+[0m[0m bucket                  = (known after apply)
      [32m+[0m[0m id                      = (known after apply)
      [32m+[0m[0m ignore_public_acls      = true
      [32m+[0m[0m restrict_public_buckets = true
    }

[1m  # module.storage.aws_s3_bucket.processed[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket" "processed" {
      [32m+[0m[0m acceleration_status         = (known after apply)
      [32m+[0m[0m acl                         = (known after apply)
      [32m+[0m[0m arn                         = (known after apply)
      [32m+[0m[0m bucket                      = "datalake-processed-dev"
      [32m+[0m[0m bucket_domain_name          = (known after apply)
      [32m+[0m[0m bucket_prefix               = (known after apply)
      [32m+[0m[0m bucket_regional_domain_name = (known after apply)
      [32m+[0m[0m force_destroy               = false
      [32m+[0m[0m hosted_zone_id              = (known after apply)
      [32m+[0m[0m id                          = (known after apply)
      [32m+[0m[0m object_lock_enabled         = (known after apply)
      [32m+[0m[0m policy                      = (known after apply)
      [32m+[0m[0m region                      = (known after apply)
      [32m+[0m[0m request_payer               = (known after apply)
      [32m+[0m[0m tags                        = {
          [32m+[0m[0m "Zone" = "Processed"
        }
      [32m+[0m[0m tags_all                    = {
          [32m+[0m[0m "Zone" = "Processed"
        }
      [32m+[0m[0m website_domain              = (known after apply)
      [32m+[0m[0m website_endpoint            = (known after apply)

      [32m+[0m[0m cors_rule (known after apply)

      [32m+[0m[0m grant (known after apply)

      [32m+[0m[0m lifecycle_rule (known after apply)

      [32m+[0m[0m logging (known after apply)

      [32m+[0m[0m object_lock_configuration (known after apply)

      [32m+[0m[0m replication_configuration (known after apply)

      [32m+[0m[0m server_side_encryption_configuration (known after apply)

      [32m+[0m[0m versioning (known after apply)

      [32m+[0m[0m website (known after apply)
    }

[1m  # module.storage.aws_s3_bucket.raw[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket" "raw" {
      [32m+[0m[0m acceleration_status         = (known after apply)
      [32m+[0m[0m acl                         = (known after apply)
      [32m+[0m[0m arn                         = (known after apply)
      [32m+[0m[0m bucket                      = "datalake-raw-dev"
      [32m+[0m[0m bucket_domain_name          = (known after apply)
      [32m+[0m[0m bucket_prefix               = (known after apply)
      [32m+[0m[0m bucket_regional_domain_name = (known after apply)
      [32m+[0m[0m force_destroy               = false
      [32m+[0m[0m hosted_zone_id              = (known after apply)
      [32m+[0m[0m id                          = (known after apply)
      [32m+[0m[0m object_lock_enabled         = (known after apply)
      [32m+[0m[0m policy                      = (known after apply)
      [32m+[0m[0m region                      = (known after apply)
      [32m+[0m[0m request_payer               = (known after apply)
      [32m+[0m[0m tags                        = {
          [32m+[0m[0m "Zone" = "Raw"
        }
      [32m+[0m[0m tags_all                    = {
          [32m+[0m[0m "Zone" = "Raw"
        }
      [32m+[0m[0m website_domain              = (known after apply)
      [32m+[0m[0m website_endpoint            = (known after apply)

      [32m+[0m[0m cors_rule (known after apply)

      [32m+[0m[0m grant (known after apply)

      [32m+[0m[0m lifecycle_rule (known after apply)

      [32m+[0m[0m logging (known after apply)

      [32m+[0m[0m object_lock_configuration (known after apply)

      [32m+[0m[0m replication_configuration (known after apply)

      [32m+[0m[0m server_side_encryption_configuration (known after apply)

      [32m+[0m[0m versioning (known after apply)

      [32m+[0m[0m website (known after apply)
    }

[1m  # module.storage.aws_s3_bucket_lifecycle_configuration.raw[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_lifecycle_configuration" "raw" {
      [32m+[0m[0m bucket                                 = (known after apply)
      [32m+[0m[0m id                                     = (known after apply)
      [32m+[0m[0m transition_default_minimum_object_size = (known after apply)

      [32m+[0m[0m rule {
          [32m+[0m[0m id     = "transition_to_ia"
          [32m+[0m[0m status = "Enabled"

          [32m+[0m[0m transition {
              [32m+[0m[0m days          = 90
              [32m+[0m[0m storage_class = "STANDARD_IA"
                [90m# (1 unchanged attribute hidden)[0m[0m
            }
        }
    }

[1m  # module.storage.aws_s3_bucket_public_access_block.processed[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_public_access_block" "processed" {
      [32m+[0m[0m block_public_acls       = true
      [32m+[0m[0m block_public_policy     = true
      [32m+[0m[0m bucket                  = (known after apply)
      [32m+[0m[0m id                      = (known after apply)
      [32m+[0m[0m ignore_public_acls      = true
      [32m+[0m[0m restrict_public_buckets = true
    }

[1m  # module.storage.aws_s3_bucket_public_access_block.raw[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_public_access_block" "raw" {
      [32m+[0m[0m block_public_acls       = true
      [32m+[0m[0m block_public_policy     = true
      [32m+[0m[0m bucket                  = (known after apply)
      [32m+[0m[0m id                      = (known after apply)
      [32m+[0m[0m ignore_public_acls      = true
      [32m+[0m[0m restrict_public_buckets = true
    }

[1m  # module.storage.aws_s3_bucket_server_side_encryption_configuration.processed[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_server_side_encryption_configuration" "processed" {
      [32m+[0m[0m bucket = (known after apply)
      [32m+[0m[0m id     = (known after apply)

      [32m+[0m[0m rule {
          [32m+[0m[0m apply_server_side_encryption_by_default {
              [32m+[0m[0m sse_algorithm     = "AES256"
                [90m# (1 unchanged attribute hidden)[0m[0m
            }
        }
    }

[1m  # module.storage.aws_s3_bucket_server_side_encryption_configuration.raw[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_server_side_encryption_configuration" "raw" {
      [32m+[0m[0m bucket = (known after apply)
      [32m+[0m[0m id     = (known after apply)

      [32m+[0m[0m rule {
          [32m+[0m[0m apply_server_side_encryption_by_default {
              [32m+[0m[0m sse_algorithm     = "AES256"
                [90m# (1 unchanged attribute hidden)[0m[0m
            }
        }
    }

[1m  # module.storage.aws_s3_bucket_versioning.processed[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_versioning" "processed" {
      [32m+[0m[0m bucket = (known after apply)
      [32m+[0m[0m id     = (known after apply)

      [32m+[0m[0m versioning_configuration {
          [32m+[0m[0m mfa_delete = (known after apply)
          [32m+[0m[0m status     = "Enabled"
        }
    }

[1m  # module.storage.aws_s3_bucket_versioning.raw[0m will be created
[0m  [32m+[0m[0m resource "aws_s3_bucket_versioning" "raw" {
      [32m+[0m[0m bucket = (known after apply)
      [32m+[0m[0m id     = (known after apply)

      [32m+[0m[0m versioning_configuration {
          [32m+[0m[0m mfa_delete = (known after apply)
          [32m+[0m[0m status     = "Enabled"
        }
    }

[1mPlan:[0m 43 to add, 0 to change, 3 to destroy.
[0m
Changes to Outputs:
  [32m+[0m[0m processed_bucket_name      = (known after apply)
  [32m+[0m[0m raw_bucket_name            = (known after apply)
[90m
─────────────────────────────────────────────────────────────────────────────[0m

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
